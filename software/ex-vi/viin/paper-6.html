<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
<HEAD>
<TITLE>An Introduction to Display Editing with Vi - Section 6</TITLE>
<!-- Sccsid @(#)paper-6.html	1.8 (gritter) 3/3/02 -->
<!-- This file was originally generated by unroff 1.0, 03/14/97 13:33:36. -->
<!-- Derived from the FreeBSD document collection. -->
<LINK REL=stylesheet TYPE="text/css" HREF="paper.css">
</HEAD><BODY>
<H2><A NAME="section33">6.</A>&nbsp;&nbsp;Special topics
</H2>
<H2><A NAME="section34">6.1.</A>&nbsp;&nbsp;Editing on slow terminals
</H2>
<P>
&nbsp;&nbsp;When you are on a slow terminal, it is important to limit the amount
of output which is generated to your screen so that you will not suffer
long delays, waiting for the screen to be refreshed.  We have already
pointed out how the editor optimizes the updating of the screen during
insertions on dumb terminals to limit the delays, and how the editor erases
lines to @ when they are deleted on dumb terminals.
<P>
&nbsp;&nbsp;The use of the slow terminal insertion mode is controlled by the
<I>slowopen
</I>option.  You can force the editor to use this mode even on faster terminals
by giving the command <B>:se slow</B>CR.  If your system is sluggish
this helps lessen the amount of output coming to your terminal.
You can disable this option by <B>:se noslow</B>CR.
<P>
&nbsp;&nbsp;The editor can simulate an intelligent terminal on a dumb one.  Try
giving the command <B>:se redraw</B>CR.  This simulation generates
a great deal of output and is generally tolerable only on lightly loaded
systems and fast terminals.  You can disable this by giving the command
 <B>:se noredraw</B>CR.
<P>
&nbsp;&nbsp;The editor also makes editing more pleasant at low speed by starting
editing in a small window, and letting the window expand as you edit.
This works particularly well on intelligent terminals.  The editor can
expand the window easily when you insert in the middle of the screen
on these terminals.  If possible, try the editor on an intelligent terminal
to see how this works.
<P>
&nbsp;&nbsp;You can control the size of the window which is redrawn each time the
screen is cleared by giving window sizes as argument to the commands
which cause large screen motions:
<DL><DT><DD>
<PRE>
<B>:  /  ?  [[  ]]  `  '
</B></PRE>
</DL>
Thus if you are searching for a particular instance of a common string
in a file you can precede the first search command by a small number,
say 3, and the editor will draw three line windows around each instance
of the string which it locates.
<P>
&nbsp;&nbsp;You can easily expand or contract the window, placing the current line
as you choose, by giving a number on a <B>z</B> command, after the <B>z</B>
and before the following RETURN, <B>.</B> or <B>-</B>.  Thus the
command <B>z5.</B> redraws the screen with the current line in the center
of a five line window
(<A HREF="paper-notes.html#6-1">footnote 6-1</A>).
<P>
&nbsp;&nbsp;If the editor is redrawing or otherwise updating large portions of the
display, you can interrupt this updating by hitting a DEL or RUB
as usual.  If you do this you may partially confuse the editor about
what is displayed on the screen.  You can still edit the text on
the screen if you wish; clear up the confusion
by hitting a <B>^L</B>; or move or search again, ignoring the
current state of the display.
<P>
&nbsp;&nbsp;See <A HREF="paper-7.html#section53">section 7.8</A>
on <I>open</I> mode for another way to use the
<I>vi
</I>command set on slow terminals.
<H2><A NAME="section35">6.2.</A>&nbsp;&nbsp;Options, set, and editor startup files
</H2>
<P>
&nbsp;&nbsp;The editor has a set of options, some of which have been mentioned above.
The most useful options are given in the following table.
<P>
&nbsp;&nbsp;The options are of three kinds:  numeric options, string options, and
toggle options.  You can set numeric and string options by a statement
of the form
<DL><DT><DD>
<PRE>
<B>set</B> <I>opt</I><B>=</B><I>val</I>
</PRE>
</DL>
and toggle options can be set or unset by statements of one of the forms
<DL><DT><DD>
<PRE>
<B>set</B> <I>opt</I>
<B>set</B> <B>no</B><I>opt</I>
</PRE>
</DL>
<P>
<TABLE>
<TH ALIGN=LEFT>Name</TH><TH ALIGN=LEFT>Default</TH><TH ALIGN=LEFT>Description</TH>
<TR><TD>autoindent&nbsp;&nbsp;&nbsp;&nbsp;</TD><TD>noai&nbsp;&nbsp;&nbsp;&nbsp;</TD><TD>Supply indentation automatically</TD></TR>
<TR><TD>autowrite&nbsp;&nbsp;&nbsp;&nbsp;</TD><TD>noaw&nbsp;&nbsp;&nbsp;&nbsp;</TD><TD>Automatic write before <B>:n</B>, <B>:ta</B>, <B>^&uarr;</B>, <B>!</B></TD></TR>
<TR><TD>ignorecase&nbsp;&nbsp;&nbsp;&nbsp;</TD><TD>noic&nbsp;&nbsp;&nbsp;&nbsp;</TD><TD>Ignore case in searching</TD></TR>
<TR><TD>lisp&nbsp;&nbsp;&nbsp;&nbsp;</TD><TD>nolisp&nbsp;&nbsp;&nbsp;&nbsp;</TD><TD>( { ) } commands deal with S-expressions</TD></TR>
<TR><TD>list&nbsp;&nbsp;&nbsp;&nbsp;</TD><TD>nolist&nbsp;&nbsp;&nbsp;&nbsp;</TD><TD>Tabs print as ^I; end of lines marked with $</TD></TR>
<TR><TD>magic&nbsp;&nbsp;&nbsp;&nbsp;</TD><TD>nomagic&nbsp;&nbsp;&nbsp;&nbsp;</TD><TD>The characters . [ and * are special in scans</TD></TR>
<TR><TD>number&nbsp;&nbsp;&nbsp;&nbsp;</TD><TD>nonu&nbsp;&nbsp;&nbsp;&nbsp;</TD><TD>Lines are displayed prefixed with line numbers</TD></TR>
<TR><TD>paragraphs&nbsp;&nbsp;&nbsp;&nbsp;</TD><TD>para=IPLPPPQPbpP&nbsp;&nbsp;&nbsp;&nbsp;</TD><TD>LI   Macro names which start paragraphs</TD></TR>
<TR><TD>redraw&nbsp;&nbsp;&nbsp;&nbsp;</TD><TD>nore&nbsp;&nbsp;&nbsp;&nbsp;</TD><TD>Simulate a smart terminal on a dumb one</TD></TR>
<TR><TD>sections&nbsp;&nbsp;&nbsp;&nbsp;</TD><TD>sect=NHSHH&nbsp;&nbsp;&nbsp;&nbsp;</TD><TD>HU         Macro names which start new sections</TD></TR>
<TR><TD>shiftwidth&nbsp;&nbsp;&nbsp;&nbsp;</TD><TD>sw=8&nbsp;&nbsp;&nbsp;&nbsp;</TD><TD>Shift distance for &lt;, &gt; and input <B>^D</B> and <B>^T</B></TD></TR>
<TR><TD>showmatch&nbsp;&nbsp;&nbsp;&nbsp;</TD><TD>nosm&nbsp;&nbsp;&nbsp;&nbsp;</TD><TD>Show matching ( or { as ) or } is typed</TD></TR>
<TR><TD>showmode&nbsp;&nbsp;&nbsp;&nbsp;</TD><TD>nosmd&nbsp;&nbsp;&nbsp;&nbsp;</TD><TD>Show input mode description <I>(addition)</I></TD></TR>
<TR><TD>slowopen&nbsp;&nbsp;&nbsp;&nbsp;</TD><TD>slow&nbsp;&nbsp;&nbsp;&nbsp;</TD><TD>Postpone display updates during inserts</TD></TR>
<TR><TD>term&nbsp;&nbsp;&nbsp;&nbsp;</TD><TD>dumb&nbsp;&nbsp;&nbsp;&nbsp;</TD><TD>The kind of terminal you are using.</TD></TR>
</TABLE>
<P>
These statements can be placed in your EXINIT in your environment,
or given while you are running
<I>vi
</I>by preceding them with a <B>:</B> and following them with a CR.
<P>
&nbsp;&nbsp;You can get a list of all options which you have changed by the
command <B>:set</B>CR, or the value of a single option by the
command <B>:set</B> <I>opt</I><B>?</B>CR.
A list of all possible options and their values is generated by
<B>:set all</B>CR.
Set can be abbreviated <B>se</B>.
Multiple options can be placed on one line, e.g.
<B>:se ai aw nu</B>CR.
<P>
&nbsp;&nbsp;Options set by the <B>set</B> command only last
while you stay in the editor.
It is common to want to have certain options set whenever you
use the editor.
This can be accomplished by creating a list of <I>ex</I> commands
(<A HREF="paper-notes.html#6-2">footnote 6-2</A>)
which are to be run every time you start up <I>ex</I>, <I>edit</I>,
or <I>vi</I>.
A typical list includes a <B>set</B> command, and possibly a few
<B>map</B> commands.
Since it is advisable to get these commands on one line, they can
be separated with the | character, for example:
<DL><DT><DD>
<PRE>
<B>set</B> ai aw terse|<B>map</B> @ dd|<B>map</B> # x
</PRE>
</DL>
which sets the options <I>autoindent</I>, <I>autowrite</I>, <I>terse</I>,
(the
<B>set
</B>command),
makes @ delete a line,
(the first
<B>map</B>),
and makes # delete a character,
(the second
<B>map</B>).
(See <A HREF="#section42">section 6.9</A>
for a description of the <B>map</B> command)
This string should be placed in the variable EXINIT in your environment.
If you use the shell <I>csh</I>,
put this line in the file
<I>.login
</I>in your home directory:
<DL><DT><DD>
<PRE>
setenv EXINIT '<B>set</B> ai aw terse|<B>map</B> @ dd|<B>map</B> # x'
</PRE>
</DL>
If you use the standard shell <I>sh</I>,
put these lines in the file
<I>.profile
</I>in your home directory:
<DL><DT><DD>
<PRE>
EXINIT='<B>set</B> ai aw terse|<B>map</B> @ dd|<B>map</B> # x'
export EXINIT
</PRE>
</DL>
Of course, the particulars of the line would depend on which options
you wanted to set.
<H2><A NAME="section36">6.3.</A>&nbsp;&nbsp;Recovering lost lines
</H2>
<P>
&nbsp;&nbsp;You might have a serious problem if you delete a number of lines and then
regret that they were deleted.  Despair not, the editor saves the last
9 deleted blocks of text in a set of numbered registers 1-9.
You can get the <I>n</I>'th previous deleted text back in your file by
the command
"<I>n</I><B>p</B>.
The " here says that a buffer name is to follow,
<I>n</I> is the number of the buffer you wish to try
(use the number 1 for now),
and
<B>p
</B>is the put command, which puts text in the buffer after the cursor.
If this doesn't bring back the text you wanted, hit
<B>u
</B>to undo this and then
<B>.</B>
(period)
to repeat the put command.
In general the
<B>.</B>
command will repeat the last change you made.
As a special case, when the last command refers to a numbered text buffer,
the <B>.</B> command increments the number of the buffer before repeating
the command.  Thus a sequence of the form
<DL><DT><DD>
<PRE>
<B>"1pu.u.u.</B>
</PRE>
</DL>
will, if repeated long enough, show you all the deleted text which has
been saved for you.
You can omit the
<B>u
</B>commands here to gather up all this text in the buffer, or stop after any
<B>.</B> command to keep just the then recovered text.
The command
<B>P
</B>can also be used rather than
<B>p
</B>to put the recovered text before rather than after the cursor.
<H2><A NAME="section37">6.4.</A>&nbsp;&nbsp;Recovering lost files
</H2>
<P>
&nbsp;&nbsp;If the system crashes, you can recover the work you were doing
to within a few changes.  You will normally receive mail when you next
login giving you the name of the file which has been saved for you. 
You should then change to the directory where you were when the system
crashed and give a command of the form:
<DL><DT><DD>
<PRE>
% <B>vi -r</B> <I>name</I>
</PRE>
</DL>
replacing <I>name</I> with the name of the file which you were editing.
This will recover your work to a point near where you left off
(<A HREF="paper-notes.html#6-3">footnote 6-3</A>).
<P>
&nbsp;&nbsp;You can get a listing of the files which are saved for you by giving
the command:
<DL><DT><DD>
<PRE>
% <B>vi -r</B>
</PRE>
</DL>
If there is more than one instance of a particular file saved, the editor
gives you the newest instance each time you recover it.  You can thus
get an older saved copy back by first recovering the newer copies.
<P>
&nbsp;&nbsp;For this feature to work,
<I>vi
</I>must be correctly installed by a super user on your system,
and the
<I>mail
</I>program must exist to receive mail.
The invocation &#147;<I>vi -r</I>&#148; will not always list all saved files,
but they can be recovered even if they are not listed.
<H2><A NAME="section38">6.5.</A>&nbsp;&nbsp;Continuous text input
</H2>
<P>
&nbsp;&nbsp;When you are typing in large amounts of text it is convenient to have
lines broken near the right margin automatically.  You can cause this
to happen by giving the command
<B>:se wm=10</B>CR.
This causes all lines to be broken at a space at least 10 columns
from the right hand edge of the screen.
<P>
&nbsp;&nbsp;If the editor breaks an input line and you wish to put it back together
you can tell it to join the lines with <B>J</B>.  You can give <B>J</B>
a count of the number of lines to be joined as in <B>3J</B> to join 3
lines.  The editor supplies white space, if appropriate,
at the juncture of the joined
lines, and leaves the cursor at this white space.
You can kill the white space with <B>x</B> if you don't want it.
<H2><A NAME="section39">6.6.</A>&nbsp;&nbsp;Features for editing programs
</H2>
<P>
&nbsp;&nbsp;The editor has a number of commands for editing programs.
The thing that most distinguishes editing of programs from editing of text
is the desirability of maintaining an indented structure to the body of
the program.  The editor has a
<I>autoindent
</I>facility for helping you generate correctly indented programs.
<P>
&nbsp;&nbsp;To enable this facility you can give the command <B>:se ai</B>CR.
Now try opening a new line with <B>o</B> and type some characters on the
line after a few tabs.  If you now start another line, notice that the
editor supplies white space at the beginning of the line to line it up
with the previous line.  You cannot backspace over this indentation,
but you can use <B>^D</B> key to backtab over the supplied indentation.
<P>
&nbsp;&nbsp;Each time you type <B>^D</B> you back up one position, normally to an
8 column boundary.  This amount is settable; the editor has an option
called
<I>shiftwidth
</I>which you can set to change this value.
Try giving the command <B>:se sw=4</B>CR
and then experimenting with autoindent again.
<P>
&nbsp;&nbsp;For shifting lines in the program left and right, there are operators
<B>&lt;
</B>and
<B>&gt;.
</B>These shift the lines you specify right or left by one
<I>shiftwidth.
</I>Try
<B>&lt;&lt;
</B>and
<B>&gt;&gt;
</B>which shift one line left or right, and
<B>&lt;L
</B>and
<B>&gt;L
</B>shifting the rest of the display left and right.
<P>
&nbsp;&nbsp;If you have a complicated expression and wish to see how the parentheses
match, put the cursor at a left or right parenthesis and hit <B>%</B>.
This will show you the matching parenthesis.
This works also for braces { and }, and brackets [ and ].
<P>
&nbsp;&nbsp;If you are editing C programs, you can use the <B>[[</B> and <B>]]</B> keys
to advance or retreat to a line starting with a <B>{</B>, i.e. a function
declaration at a time.  When <B>]]</B> is used with an operator it stops
after a line which starts with <B>}</B>; this is sometimes useful with
<B>y]]</B>.
<H2><A NAME="section40">6.7.</A>&nbsp;&nbsp;Filtering portions of the buffer
</H2>
<P>
&nbsp;&nbsp;You can run system commands over portions of the buffer using the operator
<B>!</B>.
You can use this to sort lines in the buffer, or to reformat portions
of the buffer with a pretty-printer.
Try typing in a list of random words, one per line and ending them
with a blank line.  Back up to the beginning of the list, and then give
the command <B>!}sort</B>CR.  This says to sort the next paragraph
of material, and the blank line ends a paragraph.
<H2><A NAME="section41">6.8.</A>&nbsp;&nbsp;Commands for editing LISP
</H2>
<P>
&nbsp;&nbsp;If you are editing a LISP program you should set the option
<I>lisp
</I>by doing
<B>:se lisp</B>CR.
This changes the <B>(</B> and <B>)</B> commands to move backward and forward
over s-expressions.
The <B>{</B> and <B>}</B> commands are like <B>(</B> and <B>)</B> but don't
stop at atoms.  These can be used to skip to the next list, or through
a comment quickly.
<P>
&nbsp;&nbsp;The
<I>autoindent
</I>option works differently for LISP, supplying indent to align at
the first argument to the last open list.  If there is no such argument
then the indent is two spaces more than the last level.
<P>
&nbsp;&nbsp;There is another option which is useful for typing in LISP, the
<I>showmatch
</I>option.
Try setting it with
<B>:se sm</B>CR
and then try typing a '(' some words and then a ')'.  Notice that the
cursor shows the position of the '(' which matches the ')' briefly. 
This happens only if the matching '(' is on the screen, and the cursor
stays there for at most one second.
<P>
&nbsp;&nbsp;The editor also has an operator to realign existing lines as though they
had been typed in with
<I>lisp
</I>and
<I>autoindent
</I>set.  This is the <B>=</B> operator.
Try the command <B>=%</B> at the beginning of a function.  This will realign
all the lines of the function declaration.
<P>
&nbsp;&nbsp;When you are editing LISP,, the <B>[[</B> and ]] advance
and retreat to lines beginning with a <B>(</B>, and are useful for dealing
with entire function definitions.
<H2><A NAME="section42">6.9.</A>&nbsp;&nbsp;Macros
</H2>
<P>
&nbsp;&nbsp;<I>Vi
</I>has a parameterless macro facility, which lets you set it up so that
when you hit a single keystroke, the editor will act as though
you had hit some longer sequence of keys.  You can set this up if
you find yourself typing the same sequence of commands repeatedly.
<P>
&nbsp;&nbsp;Briefly, there are two flavors of macros:
<DL>
<DT>a)<DD>
Ones where you put the macro body in a buffer register, say <I>x</I>.
You can then type <B>@x</B> to invoke the macro.  The <B>@</B> may be followed
by another <B>@</B> to repeat the last macro.
<DT>b)<DD>
You can use the
<I>map
</I>command from
<I>vi
</I>(typically in your
<I>EXINIT</I>)
with a command of the form:
<DL><DT><DD>
<PRE>
:map <I>lhs</I> <I>rhs</I>CR
</PRE>
</DL>
mapping
<I>lhs
</I>into
<I>rhs.
</I>There are restrictions:
<I>lhs
</I>should be one keystroke (either 1 character or one function key)
since it must be entered within one second
(unless
<I>notimeout
</I>is set, in which case you can type it as slowly as you wish,
and
<I>vi
</I>will wait for you to finish it before it echoes anything).
The
<I>lhs
</I>can be no longer than 10 characters, the
<I>rhs
</I>no longer than 100.
To get a space, tab or newline into
<I>lhs
</I>or
<I>rhs
</I>you should escape them with a <B>^V</B>.
(It may be necessary to double the <B>^V</B> if the map
command is given inside
<I>vi,
</I>rather than in
<I>ex.)
</I>Spaces and tabs inside the
<I>rhs
</I>need not be escaped.
</DL>
<P>
&nbsp;&nbsp;Thus to make the <B>q</B> key write and exit the editor, you can give
the command
<DL><DT><DD>
<PRE>
:map q :wq<B>^V^V</B>CR CR
</PRE>
</DL>
which means that whenever you type <B>q</B>, it will be as though you
had typed the four characters <B>:wq</B>CR.
A <B>^V</B>'s is needed because without it the CR would end the
<B>:</B> command, rather than becoming part of the
<I>map
</I>definition.
There are two
<B>^V</B>'s
because from within
<I>vi</I>,
two
<B>^V</B>'s
must be typed to get one.
The first CR is part of the
<I>rhs</I>,
the second terminates the : command.
<P>
&nbsp;&nbsp;Macros can be deleted with
<DL><DT><DD>
<PRE>
unmap lhs
</PRE>
</DL>
<P>
&nbsp;&nbsp;If the
<I>lhs
</I>of a macro is &#147;#0&#148; through &#147;#9&#148;,
this maps the particular function key
instead of the 2 character &#147;#&#148; sequence.  So that terminals without
function keys can access such definitions,
the form &#147;#x&#148; will mean function key
<I>x
</I>on all terminals (and need not be typed within one second.)
The character &#147;#&#148; can be changed by using a macro in the usual way:
<DL><DT><DD>
<PRE>
:map <B>^V^V^I</B> #
</PRE>
</DL>
to use tab, for example.  (This won't affect the
<I>map
</I>command, which still uses
<B>#,
</B>but just the invocation from visual mode.
<P>
&nbsp;&nbsp;The undo command reverses an entire macro call as a unit,
if it made any changes.
<P>
&nbsp;&nbsp;Placing a '!' after the word
<B>map
</B>causes the mapping to apply
to input mode, rather than command mode.
Thus, to arrange for <B>^T</B> to be the same as 4 spaces in input mode,
you can type:
<DL><DT><DD>
<PRE>
:map! <B>^T</B> <B>^V</B>b/b/b/b/
<!-- Note: ! character added by gritter -->
</PRE>
</DL>
where
<B>b/
</B>is a blank.
The <B>^V</B> is necessary to prevent the blanks from being taken as
white space between the
<I>lhs
</I>and
<I>rhs</I>.
<H2><A NAME="section43">6.10.</A>&nbsp;&nbsp;Word Abbreviations
</H2>
<P>
&nbsp;&nbsp;A feature similar to macros in input mode is word abbreviation.
This allows you to type a short word and have it expanded into
a longer word or words.
The commands are
<B>:abbreviate
</B>and
<B>:unabbreviate
</B>(<B>:ab</B>
and
<B>:una</B>)
and have the same syntax as
<B>:map</B>.
For example:
<DL><DT><DD>
<PRE>
:ab eecs Electrical Engineering and Computer Sciences
</PRE>
</DL>
causes the word 'eecs' to always be changed into the
phrase 'Electrical Engineering and Computer Sciences'.
Word abbreviation is different from macros in that
only whole words are affected.
If 'eecs' were typed as part of a larger word, it would
be left alone.
Also, the partial word is echoed as it is typed.
There is no need for an abbreviation to be a single keystroke,
as it should be with a macro.
<H2><A NAME="section44">6.11.</A>&nbsp;&nbsp;Abbreviations
</H2>
<P>
&nbsp;&nbsp;The editor has a number of short
commands which abbreviate longer commands which we
have introduced here.  You can find these commands easily
on the <A HREF="quickref.pdf">quick reference card</A>.
They often save a bit of typing and you can learn them as convenient.
<P>
<A HREF="paper.html#toc">Table of Contents</A>
&nbsp;&nbsp;&nbsp;&nbsp;
<A HREF="paper-7.html">Next: Nitty-gritty details</A>
</BODY>
</HTML>
